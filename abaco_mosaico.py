from calculo_geografico import distance_ptos

##################################################################################################################################
# FUNÇÕES DE ÁBACO E MOSAICO
##################################################################################################################################

def mtz_abaco(str1):
    """
    Retorna o ábaco correspondente ao módulo especificado.
    
    Args:
        str1: Nome do módulo (ex: "MT7", "MT8")
    
    Returns:
        list: Lista de entradas do ábaco
    """
    abacos = {}    
    abacos["MT7"] = [
        ["UP1","","PDT10/300", "BS", [(-1.0, 0.0), (-1.0, 217.143), (160.0, 217.143), (160.0, 0.0), (-1.0, 0.0)]], #ms1
        ["UP1","", "PDT10/600", "BC", [(160.0, 0.0), (160.0, 217.143), (350.0, 0.0), (160.0, 0.0)]], #ms2
        ["UP4","", "PDT10/600", "BC", [(160.0, 217.143), (160.0, 300.0), (600.0, 100.0), (600.0, 0.0), (350.0, 0.0), (160.0, 217.143)]], #ms3
        ["UP4","", "PDT10/600", "BC", [(-1.0, 217.143), (-1.0, 401.143), (160.0, 217.143), (-1.0, 217.143)]],#ms4
        ["UP4","", "PDT10/1000", "BC", [(-1.0, 401.143), (-1.0, 500.0), (600.0, 500.0), (600.0, 100.0), (160.0, 300.0), (160.0, 217.143), (-1.0, 401.143)]], #ms5
        ["U3/U3","", "PDT10/1500", "BC", [(600.0, 220.0), (600.0, 500.0), (900.0, 500.0), (900.0, 220.0), (600.0, 220.0)]], #ms6
        ["U3","", "PDT10/1000", "ES", [(600.0, 0.0), (600.0, 220.0), (900.0, 220.0), (900.0, 0.0), (600.0, 0.0)]], #ms7    
        ["U3","", "PDT10/600", "BC", [(900.0, 220.0), (1000.0, 220.0), (1000.0, 1.39955e-12), (900.0, 9.09495e-13), (900.0, 220.0)]], #ms8
        ["U3","", "PDT10/1000", "BC", [(900.0, 220.0), (900.0, 500.0), (1000.0, 500.0), (1000.0, 220.0), (900.0, 220.0)]], #ms9
        ["U3","", "PDT11/300", "BS", [(1000.0, 35.0), (1100.0, 35.0), (1100.0, 9.09495e-13), (1000.0, 1.39266e-12), (1000.0, 35.0)]], #ms10
        ["U3","", "PDT11/1000", "BC", [(1000.0, 220.0), (1100.0, 220.0), (1100.0, 35.0), (1000.0, 35.0), (1000.0, 220.0)]], #ms11
        ["U3","", "EXIST", "BE", [(1100.0, 35.0), (1200.0, 35.0), (1200.0, 9.09495e-13), (1100.0, 1.39266e-12), (1100.0, 35.0)]], #ms12
        ["U3","", "EXIST", "ES", [(1100.0, 220.0), (1200.0, 220.0), (1200.0, 35.0), (1100.0, 35.0), (1100.0, 220.0)]] #ms13
    ]  
    abacos["MT8"] = [
        ["UP1","", "PDT10/300", "BS", [(-1.0, 0.0), (160.0, 0.0), (160.0, 217.143), (-1.0, 217.143), (-1.0, 0.0)]],
        ["UP1","", "PDT10/300", "ES", [(160.0, 217.143), (160.0, 0.0), (350.0, 0.0), (160.0, 217.143)]],
        ["UP4","", "PDT10/300", "ED", [(-1.0, 217.143), (-1.0, 500.0), (160.0, 500.0), (160.0, 300.0), (600.0, 180.0), (600.0, 0.0), (350.0, 0.0), (160.0, 217.143), (-1.0, 217.143)]],
        ["U3","U3", "PDT10/300", "ED", [(600.0, 220.0), (600.0, 0.0), (900.0, 0.0), (900.0, 220.0), (600.0, 220.0)]],
        ["UP4","", "PDT10/300", "ET", [(160.0, 300.0), (160.0, 500.0), (600.0, 500.0), (600.0, 180.0), (160.0, 300.0)]],
        ["U3/U3","", "PDT10/600", "ET", [(600.0, 220.0), (600.0, 500.0), (900.0, 500.0), (900.0, 220.0), (600.0, 220.0)]],
        ["U3","", "PDT10/300", "ET", [(900.0, 220.0), (900.0, 500.0), (1100.0, 500.0), (1100.0, 220.0), (900.0, 220.0)]],
        ["U3","", "PDT10/300", "ES", [(900.0, 0.0), (900.0, 220.0), (1100.0, 220.0), (1100.0, 0.0), (900.0, 0.0)]],
        ["UP4","", "PDT10/300", "ED", [(1100.0, 217.143), (1300.0, 217.143), (1300.0, 0.0), (1100.0, 0.0), (1100.0, 217.143)]]
    ]
    return abacos.get(str1, [])

##################################################################################################################################

def point_in_polygon(polygon, point):
    """
    Verifica se um ponto está dentro de um polígono usando o algoritmo ray casting.
    
    Args:
        polygon: Lista de pontos do polígono [(x, y), ...]
        point: Ponto a verificar (x, y)
    
    Returns:
        bool: True se o ponto está dentro do polígono
    """
    x, y = point
    odd = False
    j = len(polygon) - 1
    for i in range(len(polygon)):
        xi, yi = polygon[i]
        xj, yj = polygon[j]
        if ((yi < y and yj >= y) or (yj < y and yi >= y)):
            if xi + (y - yi) / (yj - yi) * (xj - xi) < x:
                odd = not odd
        j = i
    return odd

##################################################################################################################################

def mosaico(ang1, dist1, str1):
    """
    Encontra a correspondência no ábaco baseado no ângulo e distância.
    
    Args:
        ang1: Ângulo multiplicado por 10
        dist1: Distância em metros
        str1: Nome do módulo
    
    Returns:
        list: [estrutura_mt, estrutura_bt, poste, base] ou None se não encontrar
    """
    ang1 = ang1 * 10
    abaco = mtz_abaco(str1)
    ptx = (ang1, dist1)

    for entry in abaco:
        def_estrutura, def_estruturabt,  def_poste, def_base, polygon = entry
        if point_in_polygon(polygon, ptx):
            return [def_estrutura, def_estruturabt, def_poste, def_base]

    ## se não der nada tem que retornar algo padrão
    print(f"ERRO: Não foi possível encontrar correspondência no ábaco para:")
    print(f"  - Ângulo: {ang1}")
    print(f"  - Distância: {dist1}")
    print(f"  - Módulo: {str1}")
    print(f"  - Ponto: {ptx}")
    print(f"  - Ábaco disponível: {len(abaco)} entradas")
    return None 